Video Solution,Category,Question,Link,Notes
https://youtu.be/3OamzN90kPg,Arrays & Hashing,Contains Duplicate,https://leetcode.com/problems/contains-duplicate/,"hashset to get unique values in array, to check for duplicates easily"
https://youtu.be/KLlXCFG5TnA,Arrays & Hashing,Two Sum,https://leetcode.com/problems/two-sum/,"use hash map to instantly check for difference value, map will add index of last occurrence of a num, don’t use same element twice;"
https://youtu.be/9UtInBqnCgA,Arrays & Hashing,Valid Anagram,https://leetcode.com/problems/valid-anagram/,"Use an array of size 26 to represent all lowercase chars, and increment each letter using ord method to get the ascii value of a letter."
https://youtu.be/vzdNOK2oB2E,Arrays & Hashing,Group Anagrams,https://leetcode.com/problems/group-anagrams/,"for each of 26 chars, use count of each char in each word as tuple for key in dict, value is the list of anagrams;"
https://youtu.be/YPTqKIgVk-k,Arrays & Hashing,Top K Frequent Elements,https://leetcode.com/problems/top-k-frequent-elements/,"minheap that’s kept at size k, if its bigger than k pop the min, by the end it should be left with k largest;  This can also be solved using quick_select for optimal time complexity on the average case"
https://youtu.be/bNvIQI2wAjk,Arrays & Hashing,Product of Array Except Self,https://leetcode.com/problems/product-of-array-except-self/,"make two passes, first in-order, second in-reverse, to compute products"
https://www.youtube.com/watch?v=TjFXEUCMqI8,Arrays & Hashing,Valid Sudoku,https://leetcode.com/problems/valid-sudoku/,"Create a method that checks if the len of the set of values in a single row is the same is the length of the row(i.e. no duplicate values in the row), then create 3 matrices, the first is the original board(checking rows), the second is the original board transposed(moving the columns to rows and checking them), and the last is a board where each row is a single square of the original board. validate each of the matrices using the method described above and return the result."
https://youtu.be/B1k_sxOSgv8,Arrays & Hashing,Encode and Decode Strings (Leetcode Premium),https://leetcode.com/problems/encode-and-decode-strings/,"store the lengths of each strings with a delimiter of ""."" than a delimiter of ""#"" between the lengths and the strings and eventually concat all the letters one after the other."
https://youtu.be/P6RZZMu_maU,Arrays & Hashing,Longest Consecutive Sequence,https://leetcode.com/problems/longest-consecutive-sequence/,"add each num to hashset, for each num if num-1 doesn’t exist, count the consecutive nums after num if they exist in the hashset, ie num+1 in hashset;"
https://www.youtube.com/watch?v=BHr381Guz3Y&ab_channel=NeetCode,Arrays & Hashing,Rotate Array,https://leetcode.com/problems/rotate-array/,
https://youtu.be/jJXJ16kPFWg,Two Pointers,Valid Palindrome,https://leetcode.com/problems/valid-palindrome/,"left, right pointers, update left and right until each points at alphanum, compare left and right, continue until left >= right, don’t distinguish between upper/lowercase;"
https://www.youtube.com/watch?v=cQ1Oz4ckceM&ab_channel=NeetCode,Two Pointers,Two Sum 2,https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/,"Initiate two pointers, left=0 and right=len(nums)-1 and a current sum = nums[left]+nums[right], while curr_sum != target, increment left if its smaller else decrement right;"
https://youtu.be/jzZsG8n2R9A,Two Pointers,3Sum,https://leetcode.com/problems/3sum/,"sort input, for each first element, find next two where -a = b+c, if a=prevA, skip a, if b=prevB skip b to elim duplicates; to find b,c use two pointers, left/right on remaining list;"
https://youtu.be/UuiTKBwPgAo,Two Pointers,Container With Most Water,https://leetcode.com/problems/container-with-most-water/,"shrinking window, left/right initially at endpoints, calculate current largest area, and check for max. increment left if height[left] <= height[right] else decrement right;"
https://www.youtube.com/watch?v=ZI2z5pq0TqA,Two Pointers,Trapping Water,https://leetcode.com/problems/trapping-rain-water/,"init pointers at the start and end of the array, and maintain left_max and right_max, if iterate on the array while left < right if max_left < max_right move left forward and update left_max then do res+=max_left - height[l] else do the same thing on the right side, and decrease right by one, return the result."
https://youtu.be/1pkOgXD63yU,Sliding Window,Best Time to Buy and Sell Stock,https://leetcode.com/problems/best-time-to-buy-and-sell-stock/,"start with left=0 then run a forloop on the stacks, as long as profit=stock[right] - stock[left] > 0 keep left where it is, when profit<0 move left to where right is now. keep checking max_profit at each iteration."
https://youtu.be/wiGpQwVHdE0,Sliding Window,Longest Substring Without Repeating Characters,https://leetcode.com/problems/longest-substring-without-repeating-characters/,"sliding window, if we see same char twice within curr window, shift start position forward;"
https://www.youtube.com/watch?v=UbyhOgBN834,Sliding Window,Permutation in String,https://leetcode.com/problems/permutation-in-string/,"Create a counter dict for s1, and a sliding window counter for s2, aswell as a left point initailized to 0. then iterate on each char in s2, and add it to the sliding windows counter. if the current letter is not in s1 counter of theres more of it in the sliding window than in s1 counter move the left pointer forward and decrement from the sliding window counter accordingly, dont forget to pop letters with 0 count;"
https://youtu.be/jSto0O4AJbM,Sliding Window,Minimum Window Substring,https://leetcode.com/problems/minimum-window-substring/,"need is num of unique char in T, HAVE is num of char we have valid count for, sliding window, move right until valid, if valid, increment left until invalid, to check validity keep track if the count of each unique char is satisfied;"
https://youtu.be/WTzjTskDFMg,Stack,Valid Parentheses,https://leetcode.com/problems/valid-parentheses/,"push opening brace on stack, pop if matching close brace, at end if stack empty, return true, (you can use a dict mapping closed to open brackets);"
https://www.youtube.com/watch?v=qkLl7nAwDPo&ab_channel=NeetCode,Stack,Min Stack,https://leetcode.com/problems/min-stack/submissions/,"Create a class with a stack and a min_value field, when a push is called with a certain value compare that value to the current min, and update current min, then append to the stack (val, self.current_min) when a pop is called, delete the last element and update current_min to the one set in the top of the stack;"
https://youtu.be/iu0082c4HDE,Stack,Evaluate Polish Notation,https://leetcode.com/problems/evaluate-reverse-polish-notation/submissions/,"Use a stack, iterate over the input, when an operation is handled pop the last two numbers in the stack and then do the operation between the first to the second, append the result back to the top of the stack. if the current input is a number append it to the stack. do this until you run out of input and return the number left in the top of the stack."
https://www.youtube.com/watch?v=s9fokUqJ76A&ab_channel=NeetCode,Stack,Generate Parentheses,https://leetcode.com/problems/generate-parentheses/,"Use a stack, a counter for the closing bracket, a counter for the opening bracket. if both the closing, and the opening are of size n return the joined stack, else if open is smaller than n, append ""("" to the stack and call recursively with the update opening counter, else if the closing counter is smaller than the opening counter, append "")"" to the stack and call the method recursively with the closing counter updated."
https://www.youtube.com/watch?v=cTBiBSnjO3c,Stack,Daily Temperatures,https://leetcode.com/problems/daily-temperatures/,"Monotonic decreasing stack, each element in the stack is (idx, temp) iterate through the temperatures, append to the stack as long as the temps are decrasing, if not pop from the stack and update the result with the index popped against the current index in the iterator;"
https://www.youtube.com/watch?v=Pr6T-3yB9RM&ab_channel=NeetCode,Stack,Car Fleet,https://leetcode.com/problems/car-fleet/,"Monotonic decreasing stack, sort the zip(position, speed) of all the cars(s.t. the result is sorted by position and then by speed) and iterate over the sorted list, of positions and speeds, calculate the time to position for each car, if the time to position is slower than the top of the stack append to the stack, else keep popping from the stack until you get to an empty stack or if the top is higher then the current time to position; "
https://www.youtube.com/watch?v=s4DPM8ct1pI&ab_channel=NeetCode,Binary Search,Binary Search,https://leetcode.com/problems/binary-search/,Binary Search implementation
https://www.youtube.com/watch?v=Ber2pi2C0j0,Binary Search,Search a 2D Matrix,https://leetcode.com/problems/search-a-2d-matrix/,"Do a binary search on the whole matrix as a single array of size n*m(i.e. left = 0, right = n*m-1, where n is the number of rows and m is the number of columns) idx = (left+right//2) and then the middle = matrix[idx // m][col = idx % m] is compared against the target"
https://www.youtube.com/watch?v=U2SozAs9RzA,Binary Search,Koko Eating Bananas,https://leetcode.com/problems/koko-eating-bananas/,"Run a binary search on the speed K it takes koko to eat all the pile of bananas, calculate the time it takes and compare to the given h, if its lower-equal we need to find a slower speed(we optimize on the minimum speed) else we need to find a faster speed(to lower the time spent eating)"
https://youtu.be/U8XENwh8Oy8,Binary Search,Search in Rotated Sorted Array,https://leetcode.com/problems/search-in-rotated-sorted-array/,"find the index i where nums[i] <= nums[i-1] using binary search make sure to move left and right according to comparison of nums[mid] to nums[0]. run binary search on both of the sorted arrays accordingly and return the target index; This can also be done by a single pass of binary search with checking on each iteration if the target is inside any of the two sorted subarrays and if not its in the other one, else keep searching inside the subarray."
https://youtu.be/nIVW4P8b1VA,Binary Search,Find Minimum in Rotated Sorted Array,https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/,"find the idx i where nums[i] <= nums[i-1] using binary search, dont forget to compare the middle index to nums[0] for updating left and right, the result will be in nums[middle]"
https://www.youtube.com/watch?v=fu2cD_6E8Hw,Binary Search,Time Based Key-Value Store,https://leetcode.com/problems/time-based-key-value-store/,"create a dict mapping key <-> list of (timestamp, values) which will be sorted by timestamp. on insert use binary search to find the location of where to insert the new item. On get use binary search with the given timestamp to retrieve the correct value."
https://youtu.be/G0_I-ZF0S38,Linked List,Reverse a Linked List,https://leetcode.com/problems/reverse-linked-list/,iterate through maintaining cur and prev;
https://youtu.be/XIdigk956u0,Linked List,Merge Two Sorted Lists,https://leetcode.com/problems/merge-two-sorted-lists/,insert each node from one list into the other - use dummy head for easier solution and return dummy.next
https://youtu.be/S5bfdUTrKLM,Linked List,Reorder List,https://leetcode.com/problems/reorder-list/,"find the middle of the list using floyds algorithm, reverse second half of list make sure both halfs of the list point at the end to None, then easily reorder it;"
https://youtu.be/XVuQxVej6y8,Linked List,Remove Nth Node From End Of List,https://leetcode.com/problems/remove-nth-node-from-end-of-list/,"use dummy node at head of list, compute len of list; two pointers, second has offset of n from first;"
https://www.youtube.com/watch?v=5Y2EiZST97Y,Linked List,Copy List with Random Pointer,https://leetcode.com/problems/copy-list-with-random-pointer/,"use a hashmap and map each node to the nodes copy, if a node is not in the hashmap create it with the originals next and random pointers, use a prev variable to update the next of each node, and update the random according to the hashmap - again if exists update it using the value in the map else create it. "
https://youtu.be/gBTe7lFR3vc,Linked List,Detect Cycle in a Linked List,https://leetcode.com/problems/linked-list-cycle/,"two pointers at different speeds - one advances single node at a time, the other advances two nodes at a time, if they meet there is loop."
https://www.youtube.com/watch?v=wjYnzkAhcNk&ab_channel=NeetCode,Linked List,Find The Duplicate Number,https://leetcode.com/problems/find-the-duplicate-number/,"The easier to implement is to use the 0th index in the array and put each element in the [1,n] range in its ascending order in the nums array by placing it first in nums[0] then swapping it with nums[nums[0]]; Floyds Turtle and hare algorithm, find intersection of slow and fast Come up to this formula: 2(turtule) = hare -> 2(F+delta) = F+delta+nC -> F+delta = nC -> F = nC - delta. since hare is already at nC + delta if we initiate turtle to the head and step both him and hare one at a time until they intersect, they will intercect at C which is the start of the cycle;"
https://www.youtube.com/watch?v=5Y2EiZST97Y,Linked List,Copy List with Random Pointer,https://leetcode.com/problems/copy-list-with-random-pointer/,"use a hashmap and map each node to the nodes copy, if a node is not in the hashmap create it with the originals next and random pointers, use a prev variable to update the next of each node, and update the random according to the hashmap - again if exists update it using the value in the map else create it. "
https://www.youtube.com/watch?v=7ABFKPK2hD4&t=858s,Linked List,LRU Cache,https://leetcode.com/problems/lru-cache/,Use OrderedDict(make the class inherent from the OrderedDict) and use self.move_to_end method to control the order of the keys; Other option is to use a dict + double linked list and move the nodes in the double linked list according to the get/set actions.
https://youtu.be/q5a5OiGbT6Q,Linked List,Merge K Sorted Lists,https://leetcode.com/problems/merge-k-sorted-lists/,"divied and conquer, merge lists, N totalnodes, k-lists, O(N*logk). For each list, find min val, insert it into list, use priorityQ to optimize finding min O(N*logk)"
https://youtu.be/OnSn2XEQ4MY,Tree,Invert/Flip Binary Tree,https://leetcode.com/problems/invert-binary-tree/,"bfs to invert each of the levels, use collections.deque;"
https://youtu.be/hTM3phVI6YQ,Tree,Maximum Depth of Binary Tree,https://leetcode.com/problems/maximum-depth-of-binary-tree/,recursive dfs to find max-depth of subtrees; iterative bfs to count number of levels in tree
https://www.youtube.com/watch?v=bkxqA8Rfv04,Tree,Diameter of Binary Tree,https://leetcode.com/problems/diameter-of-binary-tree/,"recursive dfs, for the diameter of the left, and right nodes, update the diamter to max(diameter, left_diamerer+right_diameter), the recursion dfs method returns max(left_diameter, right_diameter)+1. the diameter needs to be saved outside of the method, so it can be updated on each call."
https://www.youtube.com/watch?v=QfJsau0ItOY,Tree,Balanced Binary Tree,https://leetcode.com/problems/balanced-binary-tree/solution/,"Top down recursion using a helper method, with data augmentation, return both the height and if the node is balanced or not from the recursion, and check if any of the subtrees is not balanced or if the difference between the height of root.left and root.right is greater than 1."
https://youtu.be/vRbbcKXCxOw,Tree,Same Tree,https://leetcode.com/problems/same-tree/,recursive dfs on both trees at the same time; iterative bfs compare each level of both trees
https://youtu.be/E36O5SWp-LE,Tree,Subtree of Another Tree,https://leetcode.com/problems/subtree-of-another-tree/,"top down recursion(dfs) to check if root is the same as another, than check for recursivly is another is subtree of root.left and same for root.right; traverse s to check if any subtree in s equals t;"
https://youtu.be/gs2LMfuOR9k,Tree,Lowest Common Ancestor of BST,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/,"compare p, q values to curr node, base case: one is in left, other in right subtree, then curr is lca, else move along the path of the subtree they both are;"
https://youtu.be/6ZnyEApgFYg,Tree,Binary Tree Level Order Traversal,https://leetcode.com/problems/binary-tree-level-order-traversal/,"iterative bfs, each time you want to pop from the queue check the current length of it and pop exactly that length, remember bfs is essentialy level traversal of the Tree. if the result has the same length as the current level, append a new list to the result;"
https://www.youtube.com/watch?v=d4zLyf32e3I,Tree,Binary Tree Right Side View,https://leetcode.com/problems/binary-tree-right-side-view/,"run a bfs level order traversal, make sure to keep the last element in the stack(stack[-1]) before popping from the stack as thats the rightmost element, after popping the current level from the stack and appending next level, append that node.val to the result."
https://www.youtube.com/watch?v=7cp5imvDzl4,Tree,Count Good Nodes in a Binary Tree,https://leetcode.com/problems/count-good-nodes-in-binary-tree/,"Recusivly keep a curr_max value and check if the root.val >= curr_max for each call if so add one to the counter, and update curr_max to root.val in the next recursion call, else use the same curr_max; "
https://youtu.be/s6ATEkipzow,Tree,Validate Binary Search Tree,https://leetcode.com/problems/validate-binary-search-tree/,"trick is use built in python min/max values float(""inf""), ""-inf"", as parameters and recursivly update the max_val and min_val when going left/right accordingly;"
https://youtu.be/5LUXSvjmGCw,Tree,Kth Smallest Element in a BST,https://leetcode.com/problems/kth-smallest-element-in-a-bst/,"iterative in-order traversal, when getting to a node lower the counter until k is zero -> return the kth element processed; go left until null, pop, go right once;"
https://youtu.be/ihj4IQGZ2zc,Tree,Construct Binary Tree from Preorder and Inorder Traversal,https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/,"first element in pre-order is root, elements left of root in in-order are left subtree, right of root are right subtree, recursively build subtrees;"
https://youtu.be/Hr5cWUld4vU,Tree,Binary Tree Maximum Path Sum,https://leetcode.com/problems/binary-tree-maximum-path-sum/,"helper returns maxpathsum without splitting branches, inside helper we also update maxSum by computing maxpathsum WITH a split;"
https://youtu.be/u4JAi2JJhI8,Tree,Serialize and Deserialize Binary Tree,https://leetcode.com/problems/serialize-and-deserialize-binary-tree/,"bfs every single non-null node is added to string, and it's children are added too, even if they're null, deserialize by adding each non-null node to queue, deque node, it's children are next two nodes in string;"
https://www.youtube.com/watch?v=hOjcdrqMoQ8,Heap / Priority Queue,Kth Largest Element in a Stream,https://leetcode.com/problems/kth-largest-element-in-a-stream/,"heapq in python is min-heap, initalize the heap with the first k values(O(k)) using heapify, then insert the rest n-k while popping the minimum value after each insert - return the minimum value; you can use quick_select algorithm to find the n-kth element in the sorted array ascending."
https://www.youtube.com/watch?v=B-QCq79-Vfw,Heap / Priority Queue,Last Stone Weight,https://leetcode.com/problems/last-stone-weight/,"turn the minheap to max heap(multiply by -1 all the values), then heapify all the values, extract the max 2 stones, and do the logic on them, if needed insert the new stone back to the heap, return the last stone standing or 0 if the heap is empty."
https://www.youtube.com/watch?v=rI2EBUEMfTk,Heap / Priority Queue,K Closest Points to Origin,https://leetcode.com/problems/k-closest-points-to-origin/,"quickselect, or priority_queue(implemented with heapq using tuple (prio, task)) using the distance from origin method "
https://www.youtube.com/watch?v=XEmy13g1Qxc,Heap / Priority Queue,Kth Largest Element in an Array,https://leetcode.com/problems/kth-largest-element-in-an-array/,"quickselect for the n-k'th element in sorted ascending array; or initalize a heap with the first K elements in the array then keep popping the minimum and adding elements, this will result with the K largest elements in the array - return the min of them (heap[0])"
https://www.youtube.com/watch?v=pNichitDD2E,Heap / Priority Queue,Design Twitter,https://leetcode.com/problems/design-twitter/,"Use a timer using itertools.counts(step=-1) and then use the counter as a priority in a heap created by heapq.merge(*(self._tweets[u] for u in self._followees[userId] | {userId})) note that the latest a tweet is the timer will be smaller thus the min heap will give it a higher priority, then slice the result to get the top 10 tweets using itertools.islice(heap, 10)"
https://youtu.be/pV2kpPD66nE,Graph,Number of Islands,https://leetcode.com/problems/number-of-islands/,"foreach cell, if cell is 1 and unvisited run dfs, increment count and marking each contigous 1 as visited by turning it to 0."
https://youtu.be/mQeF6bN8hMk,Graph,Clone Graph,https://leetcode.com/problems/clone-graph/,"recursive dfs, hashmap for visited nodes"
https://www.youtube.com/watch?v=iJGr1OtmH0c,Graph,Max Area of Island,https://leetcode.com/problems/max-area-of-island/,"foreach cell, if cell is 1 and unvisited run bfs and increment a counter for the current island area, when queue is finished compare against current max, ,make sure to mark each contigous 1 as visited by turning it to 0."
https://youtu.be/s-VkcjHqkGI,Graph,Pacific Atlantic Water Flow,https://leetcode.com/problems/pacific-atlantic-water-flow/,"dfs on cells adjacent to pac and atl - i.e. the borderes of the grid, find overlap of cells that are visited by both pac and atl cells;"
https://www.youtube.com/watch?v=9z2BunfoZ5Y,Graph,Surrounded Regions,https://leetcode.com/problems/surrounded-regions/,"Start from the border, of the 2d matrix and run a DFS each of the cells containing an ""O"" change it to ""E"", Then run row by row iteration on the matrix, if a cell has ""O"" change it to ""X"" elif its ""E"" then change it to ""O"" return the result."
https://www.youtube.com/watch?v=y704fEOx0s0,Graph,Rotting Oranges,https://leetcode.com/problems/rotting-oranges/,"Find all the ones put them in a set, initiate the queue with those that are adjacent to twos, run a bfs, pop the ones, change them to twos change the step, discard the changed indices from the ones set and append the next one indices which are adjacent to twos until the queue is empty, if the ones set has any elements in it return -1. keep maintaining the number of step it takes to run the algorithm."
https://www.youtube.com/watch?v=e69C6xhiSQE,Graph,Walls and Gates,https://leetcode.com/problems/walls-and-gates/,"Initiate a list of queues starting from each of the gates, and iterate over each of the with an increasing distance, and run BFS on each of them. make sure to check if the value of a room is INF before changing its value to distance, or before appending it to the queue in the BFS algorithm."
https://www.youtube.com/watch?v=EgI5nU9etnU&ab_channel=NeetCode,Graph,Course Schedule,https://leetcode.com/problems/course-schedule/,"Topological sort, start from all the courses where inorder is 0, i.e. the sources of the connectivity components, decrease the indegree of each vertex, append to the queue only if the indegree is O. If edges remain - theres at least one cycle. check this for more info https://en.wikipedia.org/wiki/Topological_sorting"
https://www.youtube.com/watch?v=Akt3glAwyfY,Graph,Course Schedule 2,https://leetcode.com/problems/course-schedule-ii/submissions/,"Topological sort, start from all the courses where inorder is 0, i.e. the sources of the connectivity components, decrease the indegree of each vertex, append to the queue only if the indegree is O. If edges remain - theres at least one cycle. Keep track of the ordered courses by appending a course on each pop from the queue."
https://www.youtube.com/watch?v=FXWRE67PLL0,Graph,Redundant Connection,https://leetcode.com/problems/redundant-connection/,"cycle ditection in an undirected graph. This is done by essentially building the adjacency list one edge at a time, while running a DFS on the edges and checking if theres a path from u,v other than the current edge we're adding thus creating a cycle in the graph; This can also be solved using a DSU(disjoint set union data structure with better preformance of O(E*a(n)) where a(n) is the inverse ackerman function.. by runing union on all the edges and if the union finds out both edges has the same parent we return that edge as the redundant connection."
https://www.youtube.com/watch?v=8f1XPm4WOUc,Graph,Number of Connected Components in an Undirected Graph,https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/,"Create an adjacency_list for the vertices and a seen set for the vertices allready visited, then iterate over the vertices, once you find a vertex that wasnt visited increment a couter, then run a dfs from that vertex to all of its connected components, return the counter result; This can also be solved with DSU(disjoint set union data structure - also called union find) where we run union on every edge in the edges and return the number of values in the parent array which have < 0 values, i.e. the number of connected components. "
https://www.youtube.com/watch?v=bXsUuownnoQ,Graph,Graph Valid Tree,https://leetcode.com/problems/graph-valid-tree/,Solve this either by running a dfs on every non seen vertex and check for cycle along the dfs path; second option is using a DSU(disjoint set union data structure) and check if theres more than one connected component or if any cycle exists by running union on all the edges and checking if it returns false and the number of values < 0 in the parent array.
https://youtu.be/A8NUOmlwOlM,Intervals,Insert Interval,https://leetcode.com/problems/insert-interval/,"Run bfs to find the index where to insert the new interval, then create a stack and append each interval, if theres an intersection of intervals with the top of the stack, pop the last interval and push the merged interval, keep doing this until all the intervals are exhausted, return the stack - the solution is in O(n) for both time and space complexity."
https://youtu.be/44H3cEC2fFM,Intervals,Merge Intervals,https://leetcode.com/problems/merge-intervals/,"Sort the intervals according to interval[0], then create a stack and iterate over the sorted list of intervals, if theres an intersection of intervals with the top of the stack, pop the last interval and push the merged interval, keep doing this until all the intervals are exhausted, return the stack - the solution is in O(n) for both time and space complexity."
https://youtu.be/FdzJmTCVyJU,Intervals,Non-Overlapping Intervals,https://leetcode.com/problems/non-overlapping-intervals/,"Sort the intervals by the start of each interval, then maintain a prev_end element and compare it to each of the intervals start, if its smaller than update the prev end with this end, else its an overlap, increment a counter and update the prev_end to the minimum between this end and prev_end."
https://youtu.be/FdzJmTCVyJU,Intervals,Meeting Rooms,https://leetcode.com/problems/meeting-rooms/,"Sort the intervals by the start of each interval, then maintain a prev_end element and compare it to each of the intervals start, if its smaller than update the prev end with this end, else its an overlap return False. at the end return True."
https://www.youtube.com/watch?v=FdzJmTCVyJU&ab_channel=NeetCode,Intervals,Meeting Rooms II,https://leetcode.com/problems/meeting-rooms-ii/,"Sort the intervals by the start of each interval, then maintain heap called free_rooms, push the end of the first interval to it. then for every interval from the second one forward, check if the start is greater than the min value of the heap, if so pop from the heap, then push the end of the current interval to the heap. return the length of free_rooms."
https://www.youtube.com/watch?v=5WZl3MMT0Eg,Greedy,Maximum Subarray,https://leetcode.com/problems/maximum-subarray/,"Maintain a current sum, and a res variable, then iterate over the array while curr_sum > 0 if its < 0 change it to 0, and check against res for maximum value."
https://www.youtube.com/watch?v=Yan0cv2cLy8,Greedy,Jump Game,https://leetcode.com/problems/jump-game/,"Start from the end, maintain a flag variable which represents the end goal you want to get to, that iterate from the end, if nums[i] + i >= flag update flag to i, return flag == 0, i.e. we've moved the flag all the way to the start."
https://www.youtube.com/watch?v=dJ7sWiOoK7g&ab_channel=NeetCode,Greedy,Jump Game 2,https://leetcode.com/problems/jump-game-ii/submissions/,"Iterate with r and l pointers, starting from 0, and use them to do a level order traversal on the decision tree of the nums[i] for each i from r to l+1, and find the farthest you can go in the array and put that in a variable, after the itreration from l to r+1 we set l to r+1 and r to farthest, and increment the res variable by 1. when r croses len(nums)-1 we stop the iteration and return res."
https://www.youtube.com/watch?v=lJwbPZGo05A&ab_channel=NeetCode,Greedy,Gas Station,https://leetcode.com/problems/gas-station/,Find the index where the total amount of gas[i]-cost[i] is the lowest and start from the index after that. if the total amount at the end of the iteration is lower than 0 then return -1 else return (minimum_index + 1  % n).